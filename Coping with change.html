<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COPING WITH CHANGE</title>
</head>
<body>
    <main>
        <header>
        <section> 
            <a href="/Hompage.html"><img src="icon.png" alt="Icon"> Software Processes</a>
        </section>

        <SECTION>
            <button>
                Chapter 2.1
                <a href="/Chapter2.1.html">Link</a>
            </button>
            <button>
                Chapter 2.2
                <a href="/Chapter2.2.html">Link</a>
            </button>
            <button>
                Chapter 2.3
                <a href="/Chapter2.3.html">Link</a>
            </button>
            
            <button>
                Chapter 2.4
                <a href="/UnfiedProcess.html">Link</a>
            </button>
        </SECTION>

            <article>
            <h1>2.3 COPING WITH CHANGE</h1>
    <h4>Change is inevitable in all large software projects.</h4>
    <p>The system requirements change as the business procuring the system responds to external pressures and management priorities change. As new technologies become available, new design and implementation possibilities emerge. Therefore whatever software process model is used, it is
essential that it can accommodate changes to the software being developed.</p>


<img src="Figure 2.8.png" alt="">
<h5>Figure 2.8 System evolution</h5>

    <p>Change adds to the costs of software development because it usually means that
        work that has been completed has to be redone. This is called rework. For example, if
        the relationships between the requirements in a system have been analyzed and new
        requirements are then identified, some or all of the requirements analysis has to be
        repeated. It may then be necessary to redesign the system to deliver the new requirements, change any programs that have been developed, and re-test the system.</p>

    <h4>There are two related approaches that may be used to reduce the costs of rework:</h4>
    <ol>
         <li> Change avoidance, where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show some key features of the system to
            customers. They can experiment with the prototype and refine their requirements before committing to high software production costs.</li>
         <li> Change tolerance, where the process is designed so that changes can be accommodated at relatively low cost. This normally involves some form of incremental development. Proposed changes may be implemented in increments that
            have not yet been developed. If this is impossible, then only a single increment
            (a small part of the system) may have to be altered to incorporate the change.</li>
    </ol>
   
    <h4>In this section, I discuss two ways of coping with change and changing system
        requirements. These are:</h4>
    <ol>
        <li> System prototyping, where a version of the system or part of the system is developed
             quickly to check the customer’s requirements and the feasibility of some design
             decisions. This supports change avoidance as it allows users to experiment with the
             system before delivery and so refine their requirements. The number of requirements change proposals made after delivery is therefore likely to be reduced.</li>
        <li> Incremental delivery, where system increments are delivered to the customer for
             comment and experimentation. This supports both change avoidance and
             change tolerance. It avoids the premature commitment to requirements for the
             whole system and allows changes to be incorporated into later increments at relatively low cost.</li>
    </ol>
    

    <p>The notion of refactoring, namely improving the structure and organization of a
       program, is also an important mechanism that supports change tolerance. I discuss
       this in Chapter 3, which covers agile methods.</p>



<img src="Figure 2.9.png" alt="">
<h5>Figure 2.9 The process of prototype development</h5>

    <h3>2.3.1 Prototyping</h3>
    <p>A prototype is an initial version of a software system that is used to demonstrate
       concepts, try out design options, and find out more about the problem and its possible solutions. Rapid, iterative development of the prototype is essential so that costs
       are controlled and system stakeholders can experiment with the prototype early in
       the software process.</p>
    <h4>A software prototype can be used in a software development process to help
        anticipate changes that may be required:</h4>

    <ol>
        <li>In the requirements engineering process, a prototype can help with the elicitation and validation of system requirements.</li>
        <li>In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li>
    </ol>

    <p>System prototypes allow users to see how well the system supports their work.
        They may get new ideas for requirements, and find areas of strength and weakness in
        the software. They may then propose new system requirements. Furthermore, as the
        prototype is developed, it may reveal errors and omissions in the requirements that
        have been proposed. A function described in a specification may seem useful and well
        defined. However, when that function is combined with other functions, users often
        find that their initial view was incorrect or incomplete. The system specification may
        then be modified to reflect their changed understanding of the requirements.
        A system prototype may be used while the system is being designed to carry out
        design experiments to check the feasibility of a proposed design. For example, a
        database design may be prototyped and tested to check that it supports efficient data
        access for the most common user queries. Prototyping is also an essential part of the
        user interface design process. Because of the dynamic nature of user interfaces, textual descriptions and diagrams are not good enough for expressing the user interface
        requirements. Therefore, rapid prototyping with end-user involvement is the only
        sensible way to develop graphical user interfaces for software systems.
        A process model for prototype development is shown in Figure 2.9. The objectives of prototyping should be made explicit from the start of the process. These may
        be to develop a system to prototype the user interface, to develop a system to validate
        functional system requirements, or to develop a system to demonstrate the feasibility of the application to managers. The same prototype cannot meet all objectives. If the
        objectives are left unstated, management or end-users may misunderstand the function of the prototype. Consequently, they may not get the benefits that they expected
        from the prototype development.
        The next stage in the process is to decide what to put into and, perhaps more
        importantly, what to leave out of the prototype system. To reduce prototyping costs
        and accelerate the delivery schedule, you may leave some functionality out of the
        prototype. You may decide to relax non-functional requirements such as response
        time and memory utilization. Error handling and management may be ignored unless
        the objective of the prototype is to establish a user interface. Standards of reliability
        and program quality may be reduced.
        The final stage of the process is prototype evaluation. Provision must be made
        during this stage for user training and the prototype objectives should be used to
        derive a plan for evaluation. Users need time to become comfortable with a new system and to settle into a normal pattern of usage. Once they are using the system normally, they then discover requirements errors and omissions.
        A general problem with prototyping is that the prototype may not necessarily be
        used in the same way as the final system. The tester of the prototype may not be typical of system users. The training time during prototype evaluation may be insufficient. If the prototype is slow, the evaluators may adjust their way of working and
        avoid those system features that have slow response times. When provided with better response in the final system, they may use it in a different way.</p>

    <h4>Developers are sometimes pressured by managers to deliver throwaway prototypes, particularly when there are delays in delivering the final version of the software. However, this is usually unwise:</h4>
    <ol>
        <li>It may be impossible to tune the prototype to meet non-functional requirements,
            such as performance, security, robustness, and reliability requirements, which
            were ignored during prototype development.</li>
        <li>Rapid change during development inevitably means that the prototype is undocumented. The only design specification is the prototype code. This is not good
            enough for long-term maintenance.</li>
        <li> The changes made during prototype development will probably have degraded
            the system structure. The system will be difficult and expensive to maintain.</li>
        <li> Organizational quality standards are normally relaxed for prototype development</li>
    </ol>

    <p>Prototypes do not have to be executable to be useful. Paper-based mock-ups of
        the system user interface (Rettig, 1994) can be effective in helping users refine an
        interface design and work through usage scenarios. These are very cheap to develop
        and can be constructed in a few days. An extension of this technique is a Wizard of
        Oz prototype where only the user interface is developed. Users interact with this
        interface but their requests are passed to a person who interprets them and outputs
        he appropriate response.</p>



<img src="Figure 2.10.png" alt="">
<h5>Figure 2.10 Incremental delivery</h5>

    <h3>2.3.2 Incremental delivery</h3>
    <p>Incremental delivery (Figure 2.10) is an approach to software development where
        some of the developed increments are delivered to the customer and deployed for use
        in an operational environment. In an incremental delivery process, customers identify, in outline, the services to be provided by the system. They identify which of the
        services are most important and which are least important to them. A number of
        delivery increments are then defined, with each increment providing a sub-set of the
        system functionality. The allocation of services to increments depends on the service
        priority, with the highest-priority services implemented and delivered first.
        Once the system increments have been identified, the requirements for the services to be delivered in the first increment are defined in detail and that increment is
        developed. During development, further requirements analysis for later increments
        can take place but requirements changes for the current increment are not accepted.
        Once an increment is completed and delivered, customers can put it into service.
        This means that they take early delivery of part of the system functionality. They can
        experiment with the system and this helps them clarify their requirements for later system increments. As new increments are completed, they are integrated with existing
        increments so that the system functionality improves with each delivered increment.</p>

    <h4>Incremental delivery has a number of advantages:</h4>
    <ol>
        <li>Customers can use the early increments as prototypes and gain experience that
            informs their requirements for later system increments. Unlike prototypes, these
            are part of the real system so there is no re-learning when the complete system is
            available.</li>
        <li> Customers do not have to wait until the entire system is delivered before they
            can gain value from it. The first increment satisfies their most critical requirements so they can use the software immediately.</li>
        <li>The process maintains the benefits of incremental development in that it should
            be relatively easy to incorporate changes into the system.</li>
        <li>As the highest-priority services are delivered first and increments then integrated, the most important system services receive the most testing. This means hat customers are less likely to encounter software failures in the most important parts of the system.</li>
    </ol>

    <h4>However, there are problems with incremental delivery:</h4>
    <ol>
        <li>Most systems require a set of basic facilities that are used by different parts of the
            system. As requirements are not defined in detail until an increment is to be
            implemented, it can be hard to identify common facilities that are needed by all
            increments.</li>
        <li>Iterative development can also be difficult when a replacement system is being
            developed. Users want all of the functionality of the old system and are often
            unwilling to experiment with an incomplete new system. Therefore, getting useful customer feedback is difficult.</li>
        <li>Iterative development can also be difficult when a replacement system is being
            developed. Users want all of the functionality of the old system and are often
            unwilling to experiment with an incomplete new system. Therefore, getting useful customer feedback is difficult.</li>
    </ol>

    <p>There are some types of system where incremental development and delivery is
        not the best approach. These are very large systems where development may involve
        teams working in different locations, some embedded systems where the software
        depends on hardware development and some critical systems where all the requirements must be analyzed to check for interactions that may compromise the safety or
        security of the system.
        These systems, of course, suffer from the same problems of uncertain and changing requirements. Therefore, to address these problems and get some of the benefits
        of incremental development, a process may be used in which a system prototype is
        developed iteratively and used as a platform for experiments with the system
        requirements and design. With the experience gained from the prototype, definitive
        requirements can then be agreed.</p>


    <h3>2.3.3 Boehm’s spiral model</h3>
<img src="Figure 2. 11.png" alt="">
<h5>Figure 2.11 Boehm’s spiral model of the software process (©IEEE 1988)</h5>

    <p>A risk-driven software process framework (the spiral model) was proposed by
        Boehm (1988). This is shown in Figure 2.11. Here, the software process is represented as a spiral, rather than a sequence of activities with some backtracking from
        one activity to another. Each loop in the spiral represents a phase of the software
        process. Thus, the innermost loop might be concerned with system feasibility, the
        next loop with requirements definition, the next loop with system design, and so on.
        The spiral model combines change avoidance with change tolerance. It assumes that changes are a result of project risks and includes explicit risk management activities
        to reduce these risks.</p>
        
     <h4>Each loop in the spiral is split into four sectors:</h4>
     <ol>
        <li>Objective setting Specific objectives for that phase of the project are defined.
            Constraints on the process and the product are identified and a detailed management plan is drawn up. Project risks are identified. Alternative strategies,
            depending on these risks, may be planned.</li>
        <li>Risk assessment and reduction For each of the identified project risks, a detailed
            analysis is carried out. Steps are taken to reduce the risk. For example, if there is a
            risk that the requirements are inappropriate, a prototype system may be developed.</li>
        <li>Development and validation After risk evaluation, a development model for the
            system is chosen. For example, throwaway prototyping may be the best development approach if user interface risks are dominant. If safety risks are the main
            consideration, development based on formal transformations may be the most
            appropriate process, and so on. If the main identified risk is sub-system integration, the waterfall model may be the best development model to use.</li>
        <li>Planning The project is reviewed and a decision made whether to continue with
            a further loop of the spiral. If it is decided to continue, plans are drawn up for the
            next phase of the project.</li>
     </ol>

<p>The main difference between the spiral model and other software process models is
its explicit recognition of risk. A cycle of the spiral begins by elaborating objectives
such as performance and functionality. Alternative ways of achieving these objectives, and dealing with the constraints on each of them, are then enumerated. Each
alternative is assessed against each objective and sources of project risk are identified. The next step is to resolve these risks by information-gathering activities such
as more detailed analysis, prototyping, and simulation.
Once risks have been assessed, some development is carried out, followed by a planning activity for the next phase of the process. Informally, risk simply means something
that can go wrong. For example, if the intention is to use a new programming language,
a risk is that the available compilers are unreliable or do not produce sufficiently efficient object code. Risks lead to proposed software changes and project problems such as
schedule and cost overrun, so risk minimization is a very important project management
activity. Risk management, an essential part of project management, is covered in
Chapter 22.
</p>

        </article>
    </main>
</body>
<footer>
    <section>
            <h2>SISTIM MEMBERS</h2>

            <ul>
                <li>Mark Angelo G. Patal</li>
                <li>Isabella Grace M. Elola</li>
                <li>Mat Jannus S. De Guzman</li>
                <li>Hazel V. Laguras</li>
            </ul>

        </section>

        
        <section>
            © 2025 SISTIM
        </section>
</footer>
</html>
